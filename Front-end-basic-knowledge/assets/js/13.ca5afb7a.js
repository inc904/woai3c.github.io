(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{379:function(e,t,a){"use strict";a.r(t);var s=a(40),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"nodejs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs"}},[e._v("#")]),e._v(" Nodejs")]),e._v(" "),a("h2",{attrs:{id:"package-json-依赖项版本号前面的-有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#package-json-依赖项版本号前面的-有什么用"}},[e._v("#")]),e._v(" package.json 依赖项版本号前面的 ~ ^ 有什么用？")]),e._v(" "),a("ul",[a("li",[e._v("~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0")]),e._v(" "),a("li",[e._v("^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0")]),e._v(" "),a("li",[e._v("不写前缀，只写版本号就不会有更新问题")])]),e._v(" "),a("h2",{attrs:{id:"项目中使用-package-lock-json-锁版本问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目中使用-package-lock-json-锁版本问题"}},[e._v("#")]),e._v(" 项目中使用 package-lock.json 锁版本问题")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/yy95/p/10441727.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("项目中使用package-lock.json锁版本问题"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.zhihu.com/question/62331583",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm install 生成的package-lock.json是什么文件？有什么用？"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000024520174",target:"_blank",rel:"noopener noreferrer"}},[e._v("npm依赖版本变动引发的惨案"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"peerdependencies-有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peerdependencies-有什么用"}},[e._v("#")]),e._v(" peerDependencies 有什么用")]),e._v(" "),a("p",[e._v("假设一个项目有如下依赖项：")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"dependencies"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"a"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1.0.0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"b"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1.0.0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"c"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1.0.0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("并且 b 和 c 也各自有依赖项 a。那么下载依赖后的项目目录是这样的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".\n├── project\n│   └── node_modules\n│       ├── a\n│       ├── b\n│       │   └── nodule_modules\n│       │       └── a\n│       └── c\n│       │   └── nodule_modules\n│       │       └── a\n")])])]),a("p",[e._v("这样会有一个问题，依赖 a 会被重复安装 3 次。这时可以使用 "),a("code",[e._v("peerDependencies")]),e._v("，它可以避免相同的依赖被重复安装。")]),e._v(" "),a("p",[e._v("现在只需要在 b 和 c 的 "),a("code",[e._v("package.json")]),e._v(" 文件加上以下代码：")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"peerDependencies"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"a"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1.0.0"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("这样在安装时就可以避免重复安装依赖了。现在下载依赖后的目录为：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".\n├── helloWorld\n│   └── node_modules\n│       ├── a\n│       ├── b\n│       └── c\n")])])]),a("ul",[a("li",[e._v("如果用户显式依赖了核心库，则可以忽略各插件的 "),a("code",[e._v("peerDependency")]),e._v(" 声明；")]),e._v(" "),a("li",[e._v("如果用户没有显式依赖核心库，则按照插件 "),a("code",[e._v("peerDependencies")]),e._v(" 中声明的版本将库安装到项目根目录中；")])]),e._v(" "),a("p",[e._v("注意，如果主项目的 a 依赖项和 b、c 安装的 a 依赖项版本不同，有可能会报错。")]),e._v(" "),a("p",[e._v("例如 b 和 c 是一个插件的时候，它们依赖于某个核心依赖才能工作。当 b c 的核心依赖版本和项目的核心依赖版本不同时，就会报错。这时使用 "),a("code",[e._v("peerDependencies")]),e._v(" 就可以很好的解决这个问题。")]),e._v(" "),a("p",[e._v("参考资料：")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000022435060",target:"_blank",rel:"noopener noreferrer"}},[e._v("一文搞懂peerDependencies"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/SamHwang1990/blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅谈npm 的依赖与版本"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[e._v("#")]),e._v(" 垃圾回收机制")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/woai3c/Notes-and-Labs/blob/master/notes/nodejs-srjc/docs/5.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("内存回收"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);