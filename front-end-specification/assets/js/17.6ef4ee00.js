(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{296:function(a,t,l){"use strict";l.r(t);var i=l(14),v=Object(i.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"loading-的作用与使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loading-的作用与使用场景"}},[a._v("#")]),a._v(" loading 的作用与使用场景")]),a._v(" "),t("h3",{attrs:{id:"作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[a._v("#")]),a._v(" 作用")]),a._v(" "),t("ol",[t("li",[a._v("防止重复请求。")]),a._v(" "),t("li",[a._v("提示用户需要等待，避免因接口请求过慢，让用户以为页面无响应，从而提升用户体验。")])]),a._v(" "),t("h3",{attrs:{id:"使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[a._v("#")]),a._v(" 使用场景")]),a._v(" "),t("p",[a._v("loading 又分为全局 loading 和局部 loading，它们的使用场景是有所不同的：")]),a._v(" "),t("ol",[t("li",[a._v("全局 loading 在请求的时候无法进行其他操作。一般适用于纯数据展示页面，这种页面没数据就没什么用，所以适合全局 loading。")]),a._v(" "),t("li",[a._v("局部 loading 在前端中使用场景比较多，一般通过点击按钮发起请求的操作都适合用局部 loading。")])]),a._v(" "),t("h3",{attrs:{id:"注意事项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[a._v("#")]),a._v(" 注意事项")]),a._v(" "),t("ol",[t("li",[a._v("接口请求与 loading 都是结合使用的，所以对于 loading 的开启和关闭，通常放在请求拦截器中。")]),a._v(" "),t("li",[a._v("页面切换时要取消所有未完成的请求，可以在路由守卫中实现。")])]),a._v(" "),t("h3",{attrs:{id:"如何实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现"}},[a._v("#")]),a._v(" 如何实现")]),a._v(" "),t("ol",[t("li",[a._v("封装一个 loading 变量，根据接口请求的开启与关闭，将它设为 "),t("code",[a._v("true")]),a._v(" 或 "),t("code",[a._v("false")]),a._v("。这样在项目里的任何地方都可以通过它来判断是否有请求在进行，从而可以在恰当的时机展示 loading。"),t("strong",[a._v("注意")]),a._v("，无论接口请求有多少个，在页面中始终只展示一个 loading。")]),a._v(" "),t("li",[a._v("如果页面有多个请求需要在不同的时间发起，则第一点中封装的 loading 变量可能在这种情况下不适合使用。这时可以在当前页面自己创建一个 loading 变量，以满足特殊场景。")]),a._v(" "),t("li",[a._v("为了在跳转页面时取消所有未完成的请求，我们需要在请求发起前的拦截器中对所有接口进行记录，记作 "),t("code",[a._v("pendingRequests")]),a._v("。在请求完成时将已完成的请求记录进行删除。这样在页面跳转时，只需要遍历并取消 "),t("code",[a._v("pendingRequests")]),a._v(" 中的请求。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);